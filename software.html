<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Document</title>
</head>
<body>
    <style>
        body{
            background-image: url('img6.jpg');
            background-repeat:repeat;
            background-size: cover;
            background-attachment: fixed;
        }
        p {
            color: white;
        }
        .div1 {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 30px;
        }
        a , h1 {
        text-decoration: none;
        color: rgba(168, 55, 55, 0.978);
        text-align: center;
       }
       .back-to-top {
  display: none;
  position: fixed;
  bottom: 20px;
  right: 20px;
  padding: 10px;
  background-color: #333;
  color: #fff;
  text-decoration: none;
}
#process{
    border: 2px solid black;
    margin: 0 auto;
     width: 50%;
     margin-bottom: 30px;
     background-color: #555;
}
#characteristics{
    border: 2px solid black;
    margin: 0 auto;
     width: 50%;
     margin-bottom: 30px;
     background-color: #555;
}
#legacy{
    border: 2px solid black;
    margin: 0 auto;
     width: 50%;
     margin-bottom: 30px;
     background-color: #555;
}
#crisis{
    border: 2px solid black;
    margin: 0 auto;
     width: 50%;
     margin-bottom: 30px;
     background-color: #555;
}
#myths{
    
    border: 2px solid black;
    margin: 0 auto;
     width: 50%;
     margin-bottom: 30px;
     background-color: #555;
}
.back-to-top:hover {
  background-color: #555;
}
.prev {
  display: none;
  position: fixed;
  bottom: 20px;
  left: 20px;
  padding: 10px;
  background-color: #333;
  color: #fff;
  text-decoration: none;
}
.prev:hover {
  background-color: #555;
}



      

    </style>
    <div class="fixed">
        <a href="#" class="back-to-top">&uarr;</a>
        <a href="Content.html" class="prev">&larr; </a>
        
    <h1>Software</h1>
    <div class="div1">
        
        <a href="#process">Software Process</a>
        <a href="#characteristics">Characteristics</a>
        <a href="#legacy">Legacy Software </a>
        <a href="#crisis">Software Crisis</a>
        <a href="#myths">Software Myths</a>

     </div>
  </div>
    <div class="div2">
        <div id="process">
        <p style="margin:10px ;color: rgba(255, 81, 68, 0.801);">Software</p>
        <p style="margin:10px ;">
            Software is: (1) instructions (computer programs) that when executed provide desired
features, function, and performance; (2) data structures that enable the programs to adequately manipulate information, and (3) descriptive information in both hard copy and
virtual forms that describes the operation and use of the programs.
There is no question that other more complete definitions could be offere
        </p>
        <p style="margin:10px ;color: rgba(255, 81, 68, 0.801);">Software Process</p>
        <p style="margin:10px ;">
            A process is a collection of activities, actions, and tasks that are performed when
some work product is to be created. An activity strives to achieve a broad objective
(e.g., communication with stakeholders) and is applied regardless of the application
domain, size of the project, complexity of the effort, or degree of rigor with which
software engineering is to be applied. An action (e.g., architectural design) encompasses a set of tasks that produce a major work product (e.g., an architectural design
model). A task focuses on a small, but well-defined objective (e.g., conducting a unit
test) that produces a tangible outcome
        </p>
    
        <p style="margin:10px ;color: rgba(255, 81, 68, 0.801);">FrameWork Activities</p>
        <p style="margin:10px ;">
            For many software projects, framework activities are applied iteratively as a
            project progresses. That is, communication, planning, modeling, construction,
              and deployment are applied repeatedly through a number of project iterations.
             Each project iteration produces a software increment that provides stakeholders with
            a subset of overall software features and functionality. As each increment is produced, the software becomes more and more complete.
        </p>
        <p style="margin:10px ;color: rgba(255, 81, 68, 0.801);">Umbrella Activities</p>
        <p style="margin:10px ;">
            Software engineering process framework activities are complemented by a number of umbrella activities. 
            In general, umbrella activities are applied throughout a software project and help a software team manage and 
            control progress, quality,
            change, and risk. Typical umbrella activities include:</br>
            1. <b>Software project tracking and control—</b>allows the software team to
            assess progress against the project plan and take any necessary action to
            maintain the schedule.</br>
            2. <b>Risk management—</b>assesses risks that may affect the outcome of the
            project or the quality of the product.<br>
            3.<b> Software quality assurance— </b>defines and conducts the activities required
            to ensure software quality.<br>
            4. <b>Technical reviews— </b>assesses software engineering work products in an effort
            to uncover and remove errors before they are propagated to the next activity.<br>
            5. <b> Measurement— </b>defines and collects process, project, and product measures
            that assist the team in delivering software that meets stakeholders’ needs;
            can be used in conjunction with all other framework and umbrella activities.<br>
            6. <b>Software configuration management— </b>manages the effects of change
            throughout the software process.<br>
            7.<b>Reusability management— </b>defines criteria for work product reuse
            (including software components) and establishes mechanisms to achieve
            reusable components.<br>
            8. <b>Work product preparation and production—</b>encompasses the activities
            required to create work products such as models, documents, logs, forms,
            and lists
                    </p>
        <p style="margin:10px ;color: rgba(255, 81, 68, 0.801);">Software Product and Types of Software</p>
        <p style="margin:10px; ">
           <b> Software Products </b>are nothing but software systems 
            delivered to the customer with the documentation 
            that describes how to install and use the system. In certain cases, software products may be part of 
            system products where hardware, as well as software, is delivered to a customer. Software products are 
            produced with the help of the software process. The software process is a way in which we produce software. 
        </p>
        <p style="margin:10px; ">
           <b>Types of software products:</b>  <br>
           Software products fall into two broad categories:<br> 
          
        </p>

   

 
  
     
      <p style="margin:10px ;"> <b>1. Generic products:</b> 
        Generic products are stand-alone systems that are developed by a production unit and sold on the open market to any customer who is able to buy them.
       <br> <b>2. Customized Products: </b>  
        Customized products are the systems that are commissioned by a particular customer. Some contractor develops the software for that customer.</p>
    </div>
    <div id="characteristics">

    
        <p style="margin:10px ;color: rgba(255, 81, 68, 0.801);">Characteristics of a good software</p>
        <p style="margin:10px ;">
            Every software must satisfy the following attributes:<br>
            Operational <br>
            Transitional <br>
            Maintenance

        </p>
        <p style="margin:10px ;">
           <b>Operational</b> 
        This characteristic let us know about how well software works in the operations which can be measured on:
        <br> 1. Budget <br>
        2. Efficiency <br>
        3. Usability <br>
        4. Dependability <br>
        5. Correctness <br>
        6. Functionality <br>
        7. Safety <br>
        8. Security <br>
        <br>
         <b>Transitional</b>
          This is an essential aspect when the software is moved from one platform to another:
         <br> 1.  Interoperability <br>
          2. Reusability <br>
          3. Portability <br>
          4. Adaptability <br>
          <br>
                <b>Maintenance</b>
                  This aspect talks about how well software has the capabilities to adapt itself in the quickly changing environment:
                  <br> 1. Flexibility <br>
                  2. Maintainability <br>
                  3. Modularity <br>
                  4. Scalability <br>
             </p>
            </div>
            <div id="legacy">
         <p style="margin:10px ;color: rgba(255, 81, 68, 0.801);">Legacy Software</p>
        <p style="margin:10px ;">
            Legacy software is an older version of a program or application
             that still functions even after newer updates or versions are available.
              Companies typically use legacy software when they have older technology systems. 
              Older computers are often only compatible with software of a similar age, so
               it's easier for companies to use legacy software instead of purchasing new equipment.
        </p>
          <p style="margin:10px ;"> <b>Advantages of Legacy Software</b> </p>
        <p style="margin:10px ;" >
          1.  Legacy softwares are familiar <br>
          2. Legacy softwares ensure continuity in the business operations<br>
          3. Legacy software replacement is painful.
        </p>
        <p style="margin:10px ;">  <b>Disadvantages of Legacy Software</b></p>
       
        <p style="margin:10px ;">
            1. Compatibility issues <br>
            2. Limited Flexibility<br>
            3. Functionality issue <br>
            4. Old interface <br>
            5. Costly Maintenance <br>
            6. Security Vulnerabilities
        </p>
    </div>
        <div id="crisis">
            <p style="margin:10px ;color: rgba(255, 81, 68, 0.801);">Software crisis</p>
            <p style="margin:10px ;">
                Software Crisis is a term used in computer science for the difficulty of
                 writing useful and efficient computer programs in the required time. The
                  software crisis was due to using the same workforce, same methods, same 
                  tools even though rapidly increasing in software demand, the complexity 
               of software, and software challenges. With the increase in the complexity
              of software, many software problems arise because existing methods were
               insufficient. If we will use the same workforce, same methods, and same
               tools after the fast increase in software demand, software complexity,
               and software challenges, then there arise some problems like software 
               budget problems, software efficiency problems, software quality problems,
             software managing and delivering problem, etc. This condition is called a software crisis.
            </p>
            <h4 style="margin-left: 10px;">Causes of Software Crisis</h4>
            <div style="margin: 10px;">
                <p>1. The cost of owning and maintaining software was as expensive as developing the software </p>
                <p>2. At that time Projects were running over-time</p>
                <p>3. At that time Software was very inefficient </p>
                <p>4. The quality of the software was low quality </p>
                <p>5. Software often did not meet user requirements</p>
                <p>6. The average software project overshoots its schedule by half</p>
                <p>7. At that time Software was never delivered</p>
                <p>8. Non-optimal resource utilization.</p>
                <p>9. Difficult to alter, debug, and enhance.</p>
                <p>10. The software complexity is harder to change. </p>
            </div>
            </div>
            <div id="myths">
                <p  style="margin:10px ;color: rgba(255, 81, 68, 0.801);">Software Myths</p>
                <p style="margin:10px ;">
                  Software myths are erroneous beliefs about software and the process that is used to
                  build it can be traced to the earliest days of computing. Myths have a number of
                  attributes that make them insidious
                </p>
                <h4 style="margin:10px ;"> Various types of Software myths: </h4>
                <p style="margin:10px ;">
                    1. <b>Management myths</b> Managers with software responsibility, like managers in
                    most disciplines, are often under pressure to maintain budgets, keep schedules from
                    slipping, and improve quality. Like a drowning person who grasps at a straw, a software
                     manager often grasps at belief in a software myth, if that belief will lessen the
                    pressure (even temporarily).
                  </p>
                  <p style="margin:10px ;">
                    <b >Myth: </b> &nbsp; &nbsp;
                    We already have a book that's full of standards and procedures for
                     building software. Won't that provide my people with everything they
                    need to know? <br/>
                    <b>Reality: </b> &nbsp; &nbsp;
                    The book of standards may very well exist, but is it used? Are software practitioners 
                    aware of its existence? Does it reflect modern
                   software engineering practice? Is it complete? Is it adaptable? Is it
                   streamlined to improve time-to-delivery while still maintaining a
                   focus on quality? In many cases, the answer to all of these questions
                    is “no.”<br/>
                    <b>Myth: </b> &nbsp; &nbsp;
                    If we get behind schedule, we can add more programmers and catch up
                    (sometimes called the “Mongolian horde” concept)<br/>
                    <b>Reality: </b> &nbsp; &nbsp;
                    Software development is not a mechanistic process like manufacturing. In the words of Brooks: 
                    “adding people to a late software project makes it later.” At first, this statement may seem
                   counterintuitive. However, as new people are added, people who
                   were working must spend time educating the newcomers, thereby
                   reducing the amount of time spent on productive development
                   effort. People can be added but only in a planned and well coordinated manner.<br/>
                   <b>Myth: </b> &nbsp; &nbsp;
                   If I decide to outsource the software project to a third party, I can just
                    relax and let that firm build it.<br/>
                    <b>Reality: </b> &nbsp; &nbsp;
                    If an organization does not understand how to manage and control
                   software projects internally, it will invariably struggle when it outsources software projects.
            
                  </p>
                  <p style="margin:10px ;">
                    2. <b>Customer myths</b> &nbsp; &nbsp;
                    A customer who requests computer software may be a person
                   at the next desk, a technical group down the hall, the marketing/sales department,
                  or an outside company that has requested software under contract. In many cases,
                  the customer believes myths about software because software managers and practitioners do little to correct misinformation. 
                  Myths lead to false expectations (by the
                  customer) and, ultimately, dissatisfaction with the developer.
                </p>
                <p style="margin:10px ;">
                  <b>Myth: </b> &nbsp; &nbsp;
                  A general statement of objectives is sufficient to begin writing
                   programs i;e we can fill in the details later <br/>
                </p>
                <p style="margin:10px ;">
                    <b>Reality: </b> &nbsp; &nbsp;
                    Although a comprehensive and stable statement of requirements is
                    not always possible, an ambiguous “statement of objectives” is a
                    recipe for disaster.. Unambiguous requirements are developed only through effective and continuous
                    communication between customer and developer.<br/>
                    <b>Myth: </b> &nbsp; &nbsp;
                    Software requirements continually change, but change can be easily
                    accommodated because software is flexible.<br/>
                    <b>Reality: </b>   &nbsp; &nbsp;
                    It is true that software requirements change, but the impact of
                    change varies with the time at which it is introduced. When requirements changes are requested early (before design or code has been
                    started), the cost impact is relatively small.16 However, as time
                    passes, the cost impact grows rapidly—resources have been committed, a design framework has been established, and change can
                    cause upheaval that requires additional resources and major design
                    modification<br/>
                  </p>
                  <p style="margin:10px ;">
                    3. <b>Practitioner's myths</b>&nbsp; &nbsp;
                    Myths that are still believed by software practitioners have
                    been fostered by over 50 years of programming culture. 
                    During the early days, programming was viewed as an art form.
                     Old ways and attitudes die hard.
                     <br/>
                     <b>Myth: </b>&nbsp;&nbsp;
                     Once we write the program and get it to work, our job is done.<br/>
                     <b>Reality:</b>&nbsp;&nbsp;
                     Someone once said that “the sooner you begin 'writing code,' the
                     longer it'll take you to get done.” Industry data indicate that between
                     60 and 80 percent of all effort expended on software will be expended
                      after it is delivered to the customer for the first time.
                      <br/>
                      <b>Myth: </b>&nbsp;&nbsp;
                      Until I get the program “running” I have no way of assessing its quality.<br/>
                     <b>Reality:</b>&nbsp;&nbsp;
                     One of the most effective software quality assurance mechanisms
                     can be applied from the inception of a project—the technical review.
                     Software reviews (described in Chapter 15) are a “quality filter” that
                     have been found to be more effective than testing for finding certain
                     classes of software defects.
                      <br/>
                      <b>Myth: </b>&nbsp;&nbsp;
                      The only deliverable work product for a successful project is the working
                      program.<br/>
                     <b>Reality:</b>&nbsp;&nbsp;
                     A working program is only one part of a software configuration that
                     includes many elements. A variety of work products (e.g., models,
                     documents, plans) provide a foundation for successful engineering
                     and, more important, guidance for software support.
                      <br/>
                      <b>Myth: </b>&nbsp;&nbsp;
                      Software engineering will make us create voluminous and unnecessary
                      documentation and will invariably slow us down.<br/>
                     <b>Reality:</b>&nbsp;&nbsp;
                     Software engineering is not about creating documents. It is about
                     creating a quality product. Better quality leads to reduced rework.
                     And reduced rework results in faster delivery times.
                  </p>
             </div>
     </div>
     <script>
        var backToTopButton = document.querySelector(".back-to-top");
      window.addEventListener("scroll", function() {
       if (window.pageYOffset > 200) {
    backToTopButton.style.display = "block";
  } else {
    backToTopButton.style.display = "none";
  }
});
var prev = document.querySelector(".prev");
      window.addEventListener("scroll", function() {
      // if (window.pageYOffset > 200) {
   prev.style.display = "block";
 // } else {
 //  prev.style.display = "none";
  }
);


     </script>
    
  
    
</body>
</html>