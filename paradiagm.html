<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Document</title>
</head>
<body>
    <style>
        body{
           background-image: url('img6.jpg');
           background-repeat: repeat;
           background-size: cover;
           background-attachment: fixed;
       }
       p {
           color: white;
       }
       #sequential{
   border: 2px solid black;
   margin: 0 auto;
    width: 50%;
    margin-bottom: 30px;
    background-color: #555;
}
#incremental{
   border: 2px solid black;
   margin: 0 auto;
    width: 50%;
    margin-bottom: 30px;
    background-color: #555;
}
#evolution{
   border: 2px solid black;
   margin: 0 auto;
    width: 50%;
    margin-bottom: 30px;
    background-color: #555;
}
#specialized{
   border: 2px solid black;
   margin: 0 auto;
    width: 50%;
    margin-bottom: 30px;
    background-color: #555;
}
       .div1 {
           display: flex;
           flex-direction: column;
           gap: 4px;
           margin-bottom: 30px;
       }
       a , h1 {
       text-decoration: none;
       color: rgba(168, 55, 55, 0.978);
       text-align: center;
      }
      .back-to-top {
 display: none;
 position: fixed;
 bottom: 20px;
 right: 20px;
 padding: 10px;
 background-color: #333;
 color: #fff;
 text-decoration: none;
}
      .back-to-top:hover {
 background-color: #555;
}
.prev {
 display: none;
 position: fixed;
 bottom: 20px;
 left: 20px;
 padding: 10px;
 background-color: #333;
 color: #fff;
 text-decoration: none;
}
.prev:hover {
 background-color: #555;
}
   </style>
    <div class="fixed">
       <a href="#" class="back-to-top">&uarr;</a>
       <a href="Content.html" class="prev">&larr; </a>
       
   <h1>Paradiagm</h1>
   <div class="div1">
       
       <a href="#sequential">Sequential</a>
       <a href="#incremental"> Incremental</a>
       <a href="#evolution">Evolutionary </a>
       <a href="#specialized">Specialized Process Models</a>
      

    </div>
 </div>
   <div class="div2">
    <div id="sequential">
        <p style="margin:10px ;color: rgba(255, 81, 68, 0.801);">
       Sequential Waterfall model</p>
  
        <p style="margin:10px ;">
        The waterfall model, sometimes called the classic life cycle, suggests a systematic,
        sequential approach  to software development that begins with customer specification of requirements and progresses through planning, modeling, construction, and
        deployment, culminating in ongoing support of the completed software . It is generally used 
        when requirements are reasonably well understood.
       <b> Advantage:</b> <br/>
        It can serve as a useful process model in situations where requirements are fixed and work is to 
        proceed to complete in a linear manner. <br/>
       </p>
       <p style="margin:10px ;">
        <b> Disadvantage:</b> <br/>
        1. Real projects rarely follow the sequential flow that the model proposes. Although the linear model 
        can accommodate iteration, it does so indirectly. As a result, changes can cause confusion as the 
        project team proceeds. <br/>
        2. It is often difficult for the customer to state all requirements explicitly. The waterfall model 
        requires this and has difficulty accommodating the natural uncertainty that exist at the beginning 
        of many projects. <br/>
       3.  The customer must have patience. A working version of the programs will not be available until 
        late in the project time-span. If a major blunder is undetected then it can be disastrous until the 
        program is reviewed. <br/>
        A variation in the representation of the waterfall model is called the V-model. <br/>
         <b>V-model</b>  depicts the relationship of quality
         assurance actions to the actions associated with communication, modeling, and
         early construction activities. As a software team moves down the left side of the V,
         basic problem requirements are refined into progressively more detailed and technical 
         representations of the problem and its solution. Once code has been generated,
         the team moves up the right side of the V, essentially performing a series of tests
         (quality assurance actions) that validate each of the models created as the team
         moved down the left side. In reality, there is no fundamental difference between the
         classic life cycle and the V-model. The V-model provides a way of visualizing how
         verification and validation actions are applied to earlier engineering work.
         <br/>
         The waterfall model is the oldest paradigm for software engineering.
         <br/>
     </div>
     <div id="incremental">
        <p style="margin:10px ;color: rgba(255, 81, 68, 0.801);">
          Incremental Process Models</p>
          <p style="margin:10px ;">
            Incremental development is particularly useful when staffing is unavailable for a 
            complete implementation by the business deadline that has been established for the project. Early 
            increments can be implemented with fewer people. If the core product is well received, additional staff can 
            be added to implement the next increment. In addition, increments can be planned to manage technical 
            risks.<br/>
            The incremental model combines elements of the waterfall model applied in an iterative fashion.
            The incremental model delivers a series of releases called increments that provide progressively 
            more functionality for the customer as each increment is delivered. 
            When an incremental model is used, the first increment is often a core product. That is, basic 
            requirements are addressed. The core product is used by the customer. As a result, a plan is 
            developed for the next increment. 
            The plan addresses the modification of the core product to better meet the needs of the customer 
            and the delivery of additional features and functionality.
            This process is repeated following the delivery of each increment, until the complete product is 
            produced.<br/>
           
          </p>
        </div>
        <div  id="evolution">
            <p style="margin:10px ;color: rgba(255, 81, 68, 0.801);">
              Evolutionary Process Models</p>
              <p style="margin:10px ;">
                Evolutionary process models produce with each iteration produce an increasingly more complete version 
                of the software with every iteration.
                Evolutionary models are iterative. They are characterized in a manner that enables software engineers 
                to develop increasingly more complete versions of the software.
                <br/>
                 There are two common evolutionary process models.
              </p>
              <p style="margin:10px ;">
                <b>1.Prototyping : </b>   If a customer defines a set of general objectives for software, but does not identify detailed 
                input, processing, or output requirements, in such situation prototyping paradigm is best approach.
                If a developer may be unsure of the efficiency of an algorithm, the adaptability of an 
                operating system then he can go for this prototyping method.
                <br/>    Although prototyping can be used as a stand-alone process model, it is more commonly used as a technique that can be implemented within the context of any one
                of the process models noted in this chapter. Regardless of the manner in which it is
                applied, the prototyping paradigm assists you and other stakeholders to better
                understand what is to be built when requirements are fuzzy.
              </p>
              <p style="margin:10px ;">
                <b>2. THE SPIRAL MODEL </b>
                The spiral model, originally proposed by Boehm, is an evolutionary software process model that 
                couples the iterative nature of prototyping with the controlled and systematic aspects of the
                 waterfall model.
                The spiral model can be adapted to apply throughout the entire life cycle of an application, from
                 concept development to maintenance.
                Using the spiral model, software is developed in a series of evolutionary releases. During early
                iterations, the release might be a paper model or prototype. During later iterations, increasingly 
                morecomplete versions of the engineered system are produced.
             <br/>
            
              </p>
             </div>
             <div id="specialized">
                <p style="margin:10px ;color: rgba(255, 81, 68, 0.801);">
                  SPECIALIZED PROCESS MODELS</p>

                <p style="margin:10px ;">
                  Specialized process models take on many of the characteristics of one or more of the
                  traditional models presented in the preceding sections. However, these models tend
                  to be applied when a specialized or narrowly defined software engineering approach
                  is chosen. <br/>
                  <b>1. Component-Based Development</b> <br/>
                  Commercial off-the-shelf (COTS) software
                  components, developed by vendors who offer them as products, provide targeted
                  functionality with well-defined interfaces that enable the component to be integrated into
                  the software that is to be built. The component-based development model incorporates
                  many of the characteristics of the spiral model. It is evolutionary in nature, demanding an
                  iterative approach to the creation of software. However, the component-based
                  development model constructs applications from prepackaged software component.
                  Modeling and construction activities begin with the identification of candidate components.
                  These components can be designed as either conventional software modules or objectoriented classes or 
                  packages of classes. Regardless of the technology that is used to create
                  the components, the component-based development model incorporates the following
                  steps: <br/>
                  1. Available component-based products are researched and evaluated for the application
                  domain in question. <br/>
                  2. Component integration issues are considered. <br/>
                  3. A software architecture is designed to accommodate the components. <br/>
                  4. Components are integrated into the architecture. <br/>
                  5. Comprehensive testing is conducted to ensure proper functionality <br/>
                  The component-based development model leads to software reuse, and reusability provides
                  software engineers with a number of measurable benefits. software engineering team can
                  achieve a reduction in development cycle time as well as a reduction in project cost if
                  component reuse becomes part of your culture.
               </p>
               <p style="margin:10px ;">
                <b>2. Formal Methods Model : </b> <br/>
                The formal methods model encompasses a set of
                activities that leads to formal mathematical specification of computer software. Formal
                methods enable to specify, develop, and verify a computer-based system by applying a
                rigorous, mathematical notation. 
               </p>
               <p style="margin:10px ;">
                A variation on this approach, called cleanroom software
                engineering is currently applied by some software development organizations. When formal
                methods are used during development, they provide a mechanism for eliminating many of
                the problems that are difficult to overcome using other software engineering paradigms.
                Ambiguity, incompleteness, and inconsistency can be discovered and corrected more easily,
                through the application of mathematical analysis. When formal methods are used during
                design, they serve as a basis for program verification and therefore enable you to discover
                and correct errors that might otherwise go undetected. The formal methods model offers
                the promise of defect-free software.There are some of the disadvantages too: <br/>
                • The development of formal models is currently quite time consuming and expensive.  <br/>
                • Because few software developers have the necessary background to apply formal  <br/>
                methods, extensive training is required.  <br/>
                • It is difficult to use the models as a communication mechanism for technically
                unsophisticated customers

              </p>

              </div>
          
       
    </div>
    <script>
       var backToTopButton = document.querySelector(".back-to-top");
     window.addEventListener("scroll", function() {
      if (window.pageYOffset > 200) {
   backToTopButton.style.display = "block";
 } else {
   backToTopButton.style.display = "none";
 }
});
var prev = document.querySelector(".prev");
     window.addEventListener("scroll", function() {
     // if (window.pageYOffset > 200) {
  prev.style.display = "block";
// } else {
//  prev.style.display = "none";
 }
);


    </script>
    
</body>
</html>